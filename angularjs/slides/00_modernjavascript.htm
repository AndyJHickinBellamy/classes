<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8"/>
	<title>Modern JavaScript</title>
	<link href="themes/bootstrap.css" rel="stylesheet" />
	<link href="themes/otc.css" rel="stylesheet" />
    <link href="../prettify/prettify.css" rel="stylesheet" />
	<script src="../scripts/jquery-1.6.4.js" type="text/javascript"></script>		
	<script src="../prettify/prettify.js" type="text/javascript"></script>
    <script src="point5.js" type="text/javascript"></script>
</head>
<body>
	<section>		
		<h1>Modern JavaScript</h1>
		<svg viewBox="0 0 512 512">
			<title>HTML5 Logo</title>  
			<polygon fill="#E44D26" points="107.644,470.877 74.633,100.62 437.367,100.62 404.321,470.819 255.778,512 			"/>
			<polygon fill="#F16529" points="256,480.523 376.03,447.246 404.27,130.894 256,130.894 			"/>
			<polygon fill="#EBEBEB" points="256,268.217 195.91,268.217 191.76,221.716 256,221.716 256,176.305 255.843,176.305 142.132,176.305 143.219,188.488 154.38,313.627 256,313.627"/>
			<polygon fill="#EBEBEB" points="256,386.153 255.801,386.206 205.227,372.55 201.994,336.333 177.419,336.333 156.409,336.333 162.771,407.634 255.791,433.457 256,433.399"/>
			<path d="M108.382,0h23.077v22.8h21.11V0h23.078v69.044H152.57v-23.12h-21.11v23.12h-23.077V0z"/>
			<path d="M205.994,22.896h-20.316V0h63.72v22.896h-20.325v46.148h-23.078V22.896z"/>
			<path d="M259.511,0h24.063l14.802,24.26L313.163,0h24.072v69.044h-22.982V34.822l-15.877,24.549h-0.397l-15.888-24.549v34.222h-22.58V0z"/>
			<path d="M348.72,0h23.084v46.222h32.453v22.822H348.72V0z"/>
			<polygon fill="#FFFFFF" points="255.843,268.217 255.843,313.627 311.761,313.627 306.49,372.521 255.843,386.191 255.843,433.435 348.937,407.634 349.62,399.962 360.291,280.411 361.399,268.217 349.162,268.217"/>
			<polygon fill="#FFFFFF" points="255.843,176.305 255.843,204.509 255.843,221.605 255.843,221.716 365.385,221.716 365.385,221.716 365.531,221.716 366.442,211.509 368.511,188.488 369.597,176.305"/>
		</svg>		
	</section>		

	<section>
		<h1>JavaScript</h1>
		<ul>
			<li>It's dynamic</li>
			<li>It's functional</li>
			<li>It has some great features</li>
			<li>But it has a dark side ...</li>		
		</ul>
	</section>

	<section>
		<h1>QUnit</h1>
		<ul>
			<li>Simple unit testing for JavaScript</li>
			<li>Include qunit.js</li>
			<li>Include qunit.css</li>
			<li>Include the boilerplate markup</li>
		</ul>
		<pre>
&lt;h1 id=&quot;qunit-header&quot;&gt;QUnit Test Suite&lt;/h1&gt;
&lt;h2 id=&quot;qunit-banner&quot;&gt;&lt;/h2&gt;
&lt;div id=&quot;qunit-testrunner-toolbar&quot;&gt;&lt;/div&gt;
&lt;h2 id=&quot;qunit-userAgent&quot;&gt;&lt;/h2&gt;
&lt;ol id=&quot;qunit-tests&quot;&gt;&lt;/ol&gt;
&lt;div id=&quot;qunit-fixture&quot;&gt;test markup&lt;/div&gt;		
		</pre>
	</section>

	<section>
		<h1>QUnit Tests</h1>
		<ul>
			<li>Wrap test code in a function</li>
			<li>Use ok, strictEqual, deepEqual, equal ...</li>
		</ul>
		<pre>

test("Test the value of true", function () {
	ok(true);
});		
		</pre>
	</section>

	<section>
		<h1>JavaScript is weakly typed</h1>
		<ul>
			<li>But - there are built-in types</li>
			<li>Variables can point to anything - anytime</li>
		</ul>
		<pre>
strictEqual(typeof ("Joy"), "string");
strictEqual(typeof (2),     "number");
strictEqual(typeof (true),  "boolean");
strictEqual(typeof(window), "object");		
		</pre>
	</section>

	<section>
		<h1>JavaScript is Object Oriented</h1>
		<ul>
			<li>Objects have state and behavior</li>
			<li>But - there are no "class" definitions</li>
		</ul>
		<pre>
strictEqual(typeof(navigator.geolocation), "object");
strictEqual(typeof(navigator.geolocation.getCurrentPosition), "function")			
		</pre>
	</section>

	<section>
		<h1>Creating objects</h1>
		<ul>
			<li>You can use the new operator, but ...</li>		
			<li>Everyone else will use an object literal</li>
		</ul>
		<pre>

var e1 = new Object();
e1.name = "Scott";
e1.department = "Engineering";

var e2 = {
    name: "Scott",
    department: "Engineering"
};		
		</pre>
	</section>

	<section>
		<h1>Objects are just hashtables</h1>
		<ul>
			<li>Use . or []</li>
		</ul>
		<pre>

var e1 = {
    name: "Scott",
    department: "Engineering"
};

strictEqual(e1["name"], e1.name);		
		</pre>
	</section>

	<section>
		<h1>Functions are objects, too</h1>
		<ul>
			<li>Pass them as parameters</li>
			<li>Assign them to variables</li>
		</ul>
		<pre>

function add(x, y) {
    return x + y;
}

var f = add;
strictEqual(8, f(5, 3));		
		</pre>
	</section>

	<section>
		<h1>Functions as methods</h1>
		<ul>
			<li>Functions invoked via an object</li>
			<li><em>this</em> keyword is <b>not</b> optional</li>
		</ul>
		<pre>
var employee = {

  name: "Scott",
  department: "Engineering",
  changeDepartment: function (newDepartment) {
    this.department = newDepartment;
  }
};		
		</pre>
	</section>

	<section>
		<h1>Consistency?</h1>
		<ul>
			<li>How to make consistent objects?</li>
			<li>A factory method?</li>			
		</ul>
		<pre>

function createEmployee(name, department) {
    return {
	    name: name,
		department: department
	};
}

var e = createEmployee("Scott", "Engineering");
			
strictEqual(e.name, "Scott");		
		</pre>
	</section>

	<section>
		<h1>Constructor Functions</h1>
		<ul>
			<li>Used with the new operator</li>
			<li>Capital first letter by convention</li>
		</ul>
		<pre>

function Employee(name, department) {
	this.name = name;
	this.department = department;
}

var employee = new Employee("Scott", "Engineering");		
		</pre>
	</section>

	<section>
		<h1>What <em>new</em> Will Do</h1>
		<ul>
			<li>Create a new, empty object</li>
			<li>Invoke constructor passing object as "this"</li>
			<li>And one more important thing...</li>
		</ul>
		<pre>
	
function Employee(name, department) {
	this.name = name;
	this.department = department;
}

var employee = {};

Employee.call(employee, "Scott", "Department");			
		</pre>
	</section>

	<section>
		<h1>Inheritance</h1>
		<ul>
			<li>What else does new do?</li>
			<li>Initializes a secret link between objects</li>
			<li>The secret link gives us inheritance</li>			
		</ul>
		<pre>

var employee = {};
ok(employee.toString);		
		</pre>
	</section>

	<section>
		<h1>Prototypes & Inheritance</h1>
		<ul>
			<li>Every object has a prototype</li>
			<li>Runtime looks into prototype to resolve members</li>
			<li>This is prototypal inheritance</li>
		</ul>
		<pre>
 		
var o = { };

strictEqual(o.toString,
	Object.getPrototypeOf(o).toString);		
		</pre>
	</section>

	<section>
		<h1>Psedoclassical Inheritance</h1>
		<ul>
			<li>Relies on constructor functions</li>
			<li>and prototype assignment</li>
		</ul>
		<pre>

var Employee = function (name, department) {
	this.name = name; 
	this.department = department;
};

var e = new Employee("Scott", "Engineering");
strictEqual(Object.getPrototypeOf(e), Employee.prototype);
		</pre>
	</section>

	<section>
		<h1>Prototype property</h1>
		<ul>
			<li>Is not the "prototype" for an object</li>
			<li>It's the prototype assigned by new</li>
		</ul>
		<pre>
		
Employee.prototype = {
	setDepartment: function (newDepartment) {
		this.department = newDepartment;
	},
	giveRaise: function(newSalary) {
		// ...
	}
};
		</pre>
	</section>

	<section>
		<h1>Scope</h1>
		<ul>
			<li>There is function scope</li>
			<li>There is global scope</li>
			<li>There is no block { } scope</li>
			<li><strong>Always</strong> use a var keyword</li>
		</ul>
		<pre>

function doWork() {
	x = 3;
	// ...
}

doWork();
var result = x === 3;		
		</pre>
	</section>

	<section>
		<h1>Namespaces</h1>
		<ul>
			<li>There are none</li>
			<li>But we can fake them ...</li>
		</ul>
		<pre>
		
var Acme = {};
Acme.Employee = function (name, department) {
    // ...
};

var employee = new Acme.Employee("Scott", "Engineering");
		</pre>
	</section>

	<section>
		<h1>Encapsulation</h1>
		<ul>
			<li>Can be done with closures</li>
		</ul>
		<pre>
		
var Employee = function (name, department) {
    this.getName = function () {
        return name;
    };
	
    this.getDepartment = function () {
        return department;
    };
};
		</pre>
	</section>

	<section>
		<h1>Module Pattern</h1>
		<ul>
			<li>Closures on a large scale</li>
			<li>Cleaner code</li>			
		</ul>
		<pre>
		
var Employee = function (name, department) {
	var getName = function () {
		return name;
	};
	var setName = function (newName) {
		name = newName;
	};

	return {
		getName: getName,
		setName: setName
	};
};
		</pre>
	
	</section>

    <section>
        <h1>Singletons</h1>
        <ul>
            <li>Can also use the module pattern</li>
            <li>And a self executing function</li>
        </ul>
        <pre>
        
var Manager = function () {
        
    var privateState = "secret";
    function setSecret(newSecret) {
        privateState = newSecret;
    }
        
    return {
        "setSecret": setSecret
    };
        
} ();
        </pre>
    </section>

    <section>
        <h1>Augmenting Objects</h1>
        <ul>
            <li>Self executing functions with a parameter</li>
        </ul>
        <pre>
        
var employee = { /* ... */ };

(function (o) {

    var secret = "secret";
    o.pluginMethod = function () {
        // ... secret available
    };

})(employee);
        </pre>
    </section>

    <section>
        <h1>Strict Model</h1>
        <ul>
            <li>Part of ECMAScript 5</li>
            <li>Backward compatible</li>
            <li>Eliminates a whole host of errors</li>
            <li><a href="http://caniuse.com/#search=strict" target="_blank">Can I Use?</a></li>
        </ul>
        <pre>
        
"use strict";
        </pre>
    </section>

    <section>
        <h1>Summary</h1>
        <ul>
            <li>Functions are powerful abstractions</li>
            <li>Be careful with scope</li>
        </ul>
    </section>

	<footer>
		(c) 2011 OdeToCode LLC
	</footer>

</body>
</html>
